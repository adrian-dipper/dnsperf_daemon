# DNS Performance Daemon

**Languages:** English (this document) | [Deutsch](README.md)

## ⚠️ Disclaimer: Glorious, Completely Unnecessary Overengineering

Yes – I am fully aware this project is absurdly overkill for something as small as "measure DNS latency every 30 seconds". What could have been a 10-line shell loop is now a pseudo-enterprise daemon with lifecycle management, graceful signal handling, reload logic, process supervision, structured logging, testing harness and protective shutdown routines.

**What it grew into (allegedly "needed"):**
- Graceful shutdown with signal traps
- Live config reload via SIGHUP
- Child process tracking & forced termination with timeout
- Interruptible sleep (because plain `sleep` felt uncivilized)
- Defensive error handling
- Structured multi-line logging with timestamp prefixing
- A test harness simulating core behaviors

**Why?** Pure curiosity and technical mischief. The code evolved through a sequence of tightly scoped feature prompts ("Add reload", "Make shutdown robust", "Kill child processes", "Improve logging", "Add tests" …) rather than a vague "make it professional" request. Iterative feature-by-feature prompting – layer upon layer – until it became comically oversized. Minimal manual curation; the AI did the heavy lifting.

**End result:** A daemon arguably more disciplined than some production estate – to perform work that could be replaced by:
```
while true; do dig +stats google.com @1.1.1.1 > /dev/null; sleep 30; done
```
But where's the fun in that?

### 🤖 AI-Generated Code Notice
Most of this code was generated by AI. Manual edits were minimal, and most of *those* were also implemented through further AI prompting. This repository is intentionally an experiment in AI-assisted incremental engineering.

**Models involved:**
- Claude 4.0 Sonnet (Anthropic) – primary generation & refactors
- Gemini 2.5 Pro (Google) – enhancement & polishing passes
- GPT-5 (OpenAI) – reasoning support & documentation shaping
- GitHub Copilot – inline completions & micro-adjustments

Sometimes you build it simply to prove you can – not because you should.

---

An OpenRC-compatible daemon that periodically measures DNS performance by resolving a curated list of domains and storing only the latest latency result.

## Features
- Periodic DNS performance measurement (default interval: 30s)
- Daily refresh of Top N (default 1000) domains from Cisco Umbrella list
- Merge of static host list + dynamic daily list
- Compact result persistence (only latest average latency)
- Structured logging into a dedicated log file
- Graceful reload of configuration without full restart
- OpenRC integration (start/stop/reload/status)

## Quick Start
```bash
sudo ./install.sh
sudo rc-service dnsperf_daemon start
rc-service dnsperf_daemon status
cat /var/lib/dnsperf_daemon/latest_result.txt
```

## Requirements
- OpenRC init system
- `dnsperf`
- `wget`
- `unzip`
- Root privileges for installation / service management

### Install dependencies (Gentoo / Alpine)
```bash
# Gentoo
e emerge -av net-dns/bind-tools net-misc/wget app-arch/unzip

# Alpine
apk add bind-tools wget unzip
```
(`dnsperf` may need to be built from source depending on distro availability.)

## Installation
```bash
chmod +x install.sh
sudo ./install.sh
```
This script installs the daemon script, OpenRC init file, config template and creates required directories.

### Manual Installation
```bash
cp bin/dns_perf_backend.sh /usr/local/bin/
chmod +x /usr/local/bin/dns_perf_backend.sh
cp init/dnsperf_daemon /etc/init.d/
chmod +x /etc/init.d/dnsperf_daemon
rc-update add dnsperf_daemon default
```

## Service Usage
```bash
rc-service dnsperf_daemon start
rc-service dnsperf_daemon status
rc-service dnsperf_daemon stop
rc-service dnsperf_daemon restart
rc-service dnsperf_daemon reload
```

## Configuration (`/etc/dnsperf_daemon.conf`)
```bash
# Interval between test cycles (seconds)
SLEEP_INTERVAL=30

# Target DNS server
DNS_SERVER="1.1.1.1"

# Query dispatch rate for dnsperf
QUERIES_PER_SECOND=20

# Domain list source (Cisco Umbrella Top 1M)
URL="http://s3-us-west-1.amazonaws.com/umbrella-static/top-1m.csv.zip"
DOMAIN_COUNT=1000

# Static domains appended before dynamic list
STATIC_HOSTS=(
  "google.de"
  "youtube.com"
  # add more if needed
)
```
Apply changes without restart:
```bash
rc-service dnsperf_daemon reload
```

## Directory & Files
| Purpose | Path |
|---------|------|
| Script | /usr/local/bin/dns_perf_backend.sh |
| Config | /etc/dnsperf_daemon.conf |
| Init Script | /etc/init.d/dnsperf_daemon |
| PID File | /var/run/dnsperf_daemon.pid |
| Log File | /var/log/dnsperf_daemon.log |
| Working Dir | /var/lib/dnsperf_daemon/ |
| Latest Result | /var/lib/dnsperf_daemon/latest_result.txt |
| Cached Domains | /var/lib/dnsperf_daemon/top_domains.txt |

## Makefile Targets
```bash
make help
make install
make start
make status
make result
make test
make test-results
```

## Testing
A backend test harness is included:
```bash
./bin/test_dns_perf_backend.sh
# or
make test
```
Test mode uses a reduced domain count, isolates temp workspace, archives results, and validates core behaviors.

## Monitoring
```bash
tail -f /var/log/dnsperf_daemon.log
cat /var/lib/dnsperf_daemon/latest_result.txt
rc-service dnsperf_daemon status
```

## Troubleshooting
| Symptom | Suggestion |
|---------|------------|
| No result file | Check log, verify dnsperf installed |
| High CPU | Lower QUERIES_PER_SECOND or raise SLEEP_INTERVAL |
| Cannot stop quickly | Ensure signals not blocked; check log for stuck child processes |

Manual sanity checks:
```bash
which dnsperf wget unzip
nslookup google.de 1.1.1.1
```

## Uninstall
```bash
rc-service dnsperf_daemon stop
rc-update del dnsperf_daemon default
rm /etc/init.d/dnsperf_daemon
rm /usr/local/bin/dns_perf_backend.sh
rm -rf /var/lib/dnsperf_daemon
rm /var/log/dnsperf_daemon.log
rm /var/run/dnsperf_daemon.pid
```

## Sample Result
```
12.345678
```
Represents average latency in seconds (6 decimal places → microsecond precision style). Full context in the log file.

## License
MIT License – see `LICENSE`.

---
If you're reading this wondering "Why?" – the answer is: *Because iterative prompting plus curiosity tends to snowball.*

